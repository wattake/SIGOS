\section{議論}
\label{sec:disc}

\subsection{パフォーマンスの向上に向けて}

\ref{sec:evaluation}章で示したように，
実アプリケーションにおいて，
現在のプロトタイプは 2 倍以上のランタイムオーバヘッドを生じる．
そのため，いくつかの最適化の技術を模索することが重要である．
オーバヘッドで重要なのは，ロギングとコンポーネント間のデータの受け渡しである．
プロトタイプでは，コンポーネントの状態を変更するような関数呼び出しを単純にログに記録していくため，
実行時のオーバヘッドが生じる．
このようなロギングを行う代わりに，状態を変更する関数呼び出しを起因とするいくつかの関数呼び出しを記憶しておくことで，
オーバヘッドを削減することができる．
起因となる関数呼び出しとその引数を，
連鎖的に呼び出される後継の関数とその引数に関連付けることで，
起因となる関数呼び出しのみをログに記録し，
起因となる関数呼び出しから後継の関数呼び出しを生成してコンポーネントに与えることで，
対象のコンポーネントを復元することができる．

スレッドスケジューラによって生じるオーバヘッドを減らすためには，
スケジューラをコンポーネントスレッドに特化させることが有効である．
現在のプロトタイプは，アプリケーションスレッドのための Unikraft のラウンドロビン方式でのスケジューラに依存している．
コンポーネントの相関関係を利用することで，スケジューリングのオーバヘッドを軽減することができる．
たとえば，ファイルシステムの主要なコンポーネントは VFS コンポーネントを実行した後に実行される傾向があり，
その逆の傾向も同様にある．
この相関関係に基づいて，コンポーネントスレッドのスケジューリングに優先順位をつけることで，
スケジューリングの待ち時間が短縮される．


\subsection{エラー伝搬}

\sysname は CubicleOS~\cite{SartakovEtAl-ASPLOS21}や FlexOS~\cite{LefeuvreEtAl-FlexOS}と同じ高い強度で分離を実現するものであるものの，
このメカニズムで防ぐことができないエラー伝搬が存在する．
そのエラー伝搬は，
関数呼び出し先のコンポーネントのエラーが関数呼び出し元のコンポーネントへと伝搬するケースである．
このケースは，正当な制御フローの範囲内にバグが存在するときに発生するものであり，
関数実行中のコンポーネントが呼び出し元のコンポーネントのデータを不当に更新することである．

このケースのエラー伝搬を完全に防ぐためには，
他のコンポーネントのデータ更新時の正当性を関数ごとに検証する必要がある．
しかし，Unikernel はリンクするアプリケーションの要件によって，
コンポーネントの構成が異なるため，
同じ関数であっても，関数の呼び出し元と呼び出し先のコンポーネントの関係が一定であるとは限らず，
データ更新の正当性を定義することが難しい．


